<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Cat.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Cat.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import { Plate } from "./Plate.js";

/**
 * Clase que contiene la lógica detrás del comportamiento de un gato
 */
export class Cat {
    constructor(scena, name, type) {
        this.animation = 'Sleep';
        this.scene = scena;
        this.type = type;
        this.name = name;
        switch (this.type) {
            case 'GREEN':
                this.color = '#23FF00';
                break;
            case 'YELLOW':
                this.color = '#FFFB00';
                break;
            default:
                this.color = '#FF2D00';
                break;
        }
        var s = '/resources/game/Entities/Cats/' + type + '/' + name + '.png';
        this.scene.load.spritesheet(name, s, {
            frameWidth: 90,
            frameHeight: 55
        });
        this.state = 'NORMAL';
        if (this.scene.socket != undefined) {
            this.scene.socket.emit("newCat", {
                password: this.scene.socket.id,
                name: this.name,
                type: this.type,
                state: 'NORMAL',
                x: 100,
                y: 600
            });
        }
        this.mindlessCat = false;
        if (this.scene.socket != undefined) {
            this.scene.socket.on("mindlessCat", () => {
                this.mindlessCat = true;
            });
        }
    }

    /**
     * Función que asigna al gato la posición indicada
     * @param {integer} posX 
     * @param {integer} posY 
     */
    setXY(posX, posY) {
        this.cat.x = posX;
        this.cat.y = posY;
    }

    create(bg) {
        this.scene.anims.create({
            key: this.name + "RunR",
            frames: this.scene.anims.generateFrameNumbers(this.name, { start: 0, end: 3 }),
            frameRate: 4,
            repeat: -1
        });
        this.scene.anims.create({
            key: this.name + "RunL",
            frames: this.scene.anims.generateFrameNumbers(this.name, { start: 4, end: 7 }),
            frameRate: 4,
            repeat: -1
        });
        this.scene.anims.create({
            key: this.name + "MadR",
            frames: this.scene.anims.generateFrameNumbers(this.name, { start: 8, end: 10 }),
            frameRate: 3,
            repeat: -1
        });
        this.scene.anims.create({
            key: this.name + "MadL",
            frames: this.scene.anims.generateFrameNumbers(this.name, { start: 12, end: 14 }),
            frameRate: 3,
            repeat: -1
        });
        this.scene.anims.create({
            key: this.name + "standR",
            frames: this.scene.anims.generateFrameNumbers(this.name, { start: 16, end: 18 }),
            frameRate: 3,
            repeat: -1
        });
        this.scene.anims.create({
            key: this.name + "standL",
            frames: this.scene.anims.generateFrameNumbers(this.name, { start: 20, end: 22 }),
            frameRate: 3,
            repeat: -1
        });
        this.scene.anims.create({
            key: this.name + "Sleep",
            frames: this.scene.anims.generateFrameNumbers(this.name, { start: 24, end: 26 }),
            frameRate: 2,
            repeat: -1
        });
        var x = Phaser.Math.Between(100, bg.displayWidth - 150);
        var y = Phaser.Math.Between(bg.displayHeight - 300, bg.displayHeight - 200);
        if (this.scene.socket != undefined) {
            this.scene.socket.emit("catPos", {
                password: this.scene.socket.id,
                name: this.name,
                x: x,
                y: y
            });
        }
        this.cat = this.scene.physics.add.sprite(x, y, this.name, 24);
        if (this.type != 'GREEN') {
            this.zone = this.scene.physics.add.image(x, y - 25, (this.type == 'RED') ? 'zoneRed' : 'zoneYellow')
            this.zone.body.allowGravity = false;
            this.action = false;
        }
        this.textName = this.scene.add.text(this.cat.x, this.cat.y - 25, this.name, {
            fontSize: '40px',
            fill: '#111',
            fontFamily: 'pixel'
        });
        if (!this.mindlessCat) {
            this.stateTimer = this.scene.time.addEvent(
                {
                    delay: Phaser.Math.Between(3000, 10000),
                    callback: this.stateChange,
                    callbackScope: this,
                    loop: true
                });
            this.moveTimer = this.scene.time.addEvent(
                {
                    delay: Phaser.Math.Between(3000, 6000),
                    callback: this.move,
                    callbackScope: this,
                    loop: true
                });
        }

        this.plateCoord = {}
        this.scene.plates.forEach(plato => {
            this.plateCoord[plato.type] = {
                x: plato.plate.x,
                y: plato.plate.y
            }
        });

        this.scene.physics.add.collider(this.cat, this.scene.plataforms.plat);
        if (this.zone != undefined)
            this.scene.physics.add.overlap(this.zone, this.scene.player.player, this.approach, null, this);
        this.scene.physics.add.overlap(this.cat, this.scene.player.player, this.toolAndCat, () => { return this.scene.player.eKey.isDown }, this);

        this.scene.plates.forEach(plate => {
            var plato = plate.plate;
            this.scene.physics.add.overlap(this.cat, plato, (cat, plato) => {
                var p = this.plateByCoord(plato.x)
                if (p.full &amp;
                    ((this.state == 'HUNGRY' &amp; p.type == 'FOOD') |
                        (this.state == 'THIRSTY' &amp; p.type == 'WATER'))) {
                    p.use();
                    this.cat.play(this.name + "Sleep");
                    if (this.scene.socket != undefined)
                        this.scene.socket.emit('catAnim', { name: this.name, animation: (this.name + "Sleep") })
                    cat.setVelocityX(0);
                    this.state = 'NORMAL';
                }
            }, null, this);
        });
        this.cat.setCollideWorldBounds(true);
    }

    update() {
        if (!this.mindlessCat &amp; this.scene.socket != undefined) {
            this.scene.socket.emit("catUpdate", {
                name: this.name,
                x: this.cat.x,
                y: this.cat.y,
                state: this.state
            });
        }
        if (this.zone != undefined) {
            this.zone.x = this.cat.x;
            this.zone.y = this.cat.y - 25
        }

        if (this.textName.x != this.cat.x - this.cat.displayWidth / 2)
            this.textName.x = this.cat.x - this.cat.displayWidth / 2;
        if (this.textName.y != this.cat.y - this.cat.displayHeight / 2 - 30)
            this.textName.y = this.cat.y - this.cat.displayHeight / 2 - 30;


    }

    /**
     * Método que contiene la logica detrás del movimiento de los gatos en base a su color en el semaforo
     * de felinorte, y su estado
     */
    move() {
        if (this.state != 'HUNGRY' &amp; this.state != 'THIRSTY') {
            var choose = Phaser.Math.Between(0, 1);
            this.cat.play((this.name + ((choose == 1) ? "RunR" : "RunL")));
            if (this.scene.socket != undefined)
                this.scene.socket.emit('catAnim', { name: this.name, animation: (this.name + ((choose == 1) ? "RunR" : "RunL")) })
            switch (this.type) {
                case 'GREEN':
                    this.cat.setVelocityX((choose == 1) ? 200 : -200);
                    if (this.cat.body.onWall() | this.cat.body.checkWorldBounds()) {
                        this.cat.setVelocityY(250);
                        this.scene.time.delayedCall(100, () => {
                            if (this.cat.body.checkWorldBounds()) {
                                this.cat.setVelocityX((choose == 1) ? -200 : 200);
                            }
                        }, [], this);
                    }
                    break;
                case 'YELLOW':
                    this.cat.setVelocityX((choose == 1) ? 200 : -200);
                    if (this.cat.body.onWall() | this.cat.body.checkWorldBounds()) {
                        this.cat.setVelocityY(250);
                        this.scene.time.delayedCall(100, () => {
                            if (this.cat.body.checkWorldBounds()) {
                                this.cat.setVelocityX((choose == 1) ? -200 : 200);
                            }
                        }, [], this);
                    }
                    break;
                case 'RED':
                    this.cat.setVelocityX((choose == 1) ? 200 : -200);
                    if (this.cat.body.onWall() | this.cat.body.checkWorldBounds()) {
                        this.cat.setVelocityY(250);
                        this.scene.time.delayedCall(100, () => {
                            if (this.cat.body.checkWorldBounds()) {
                                this.cat.setVelocityX((choose == 1) ? -200 : 200);
                            }
                        }, [], this);
                    }
                    break;
            }
            this.scene.time.delayedCall(1200, () => {
                if (!this.action) {
                    this.cat.setVelocity(0);
                    if (choose == 1) {
                        var quieto = this.name + ((Phaser.Math.Between(0, 1) == 1) ? "standR" : "Sleep");
                    } else {
                        var quieto = this.name + ((Phaser.Math.Between(0, 1) == 1) ? "standL" : "Sleep");
                    }
                    this.cat.play(quieto);
                    if (this.scene.socket != undefined)
                        this.scene.socket.emit('catAnim', { name: this.name, animation: quieto })
                }
            }, [], this);
            this.moveTimer.delay = Phaser.Math.Between(3000, 6000);
        } else {
            var t = (this.state == 'HUNGRY') ? 'FOOD' : 'WATER';
            this.cat.setVelocityX((this.plateCoord[t].x > this.cat.x) ? 200 : -200);
            this.cat.play((this.name + ((this.plateCoord[t].x > this.cat.x) ? "RunR" : "RunL")));
            if (this.scene.socket != undefined)
                this.scene.socket.emit('catAnim', { name: this.name, animation: (this.name + ((this.plateCoord[t].x > this.cat.x) ? "RunR" : "RunL")) })
            this.moveTimer.delay = Phaser.Math.Between(3000, 6000);
        }
    }

    /**
     * Método que contiene la logica detrás del cambio de estado de los gatos
     */
    stateChange() {
        this.stateTimer
        var p = Phaser.Math.Between(0, 4);
        if (this.state == 'NORMAL') {
            switch (p) {
                case 0:
                    this.state = 'HUNGRY';
                    break;
                case 1:
                    this.state = 'THIRSTY';
                    break;
                case 2:
                    this.state = 'SICK';
                    break;
                case 3:
                    this.state = 'BORED';
                    break;
                default:
                    if (this.state == 'NORMAL') this.state = 'NORMAL';
                    break;
            }
        }
        this.stateTimer.delay = Phaser.Math.Between(6000, 20000);
    }

    /**
     * Función callback que contiene el comportamiento de un gato en base a su color en el semaforo gatuno de
     * felinorte y la velocidad con la que se le aproxime el jugador
     * @param {Phaser.Physics.Arcade.image} zone 
     * @param {Phaser.Physics.Arcade.image} player 
     */
    approach(zone, player) {
        var xVel = player.body.velocity.x;
        if (xVel > 80 | xVel &lt; -80) {
            if (this.type == 'YELLOW' &amp; this.state != 'HUNGRY' &amp; this.state != 'THIRSTY') {
                if (!this.action) {
                    this.cat.play(this.name + ((xVel > 80) ? "MadL" : "MadR"));
                    if (this.scene.socket != undefined)
                        this.scene.socket.emit('catAnim', { name: this.name, animation: (this.name + ((xVel > 80) ? "MadL" : "MadR")) })
                }
                this.action = true;
                if (this.scene.socket != undefined)
                    this.scene.socket.emit("playerApproachCat", { name: this.name, playerX: player.x, zoneX: zone.x });
                if (!this.mindlessCat)
                    this.cat.setVelocity((player.x &lt; zone.x) ? 300 : -300, -300);
                this.scene.time.delayedCall(1000, () => {
                    this.action = false;
                }, [], this);
            } else if (this.type == 'RED') {
                this.scene.judge.restPoints(1);
                if (!this.action) {
                    this.cat.play(this.name + ((xVel > 80) ? "MadL" : "MadR"));
                    if (this.scene.socket != undefined)
                        this.scene.socket.emit('catAnim', { name: this.name, animation: (this.name + ((xVel > 80) ? "MadL" : "MadR")) })
                }
                this.action = true;
                this.scene.time.delayedCall(1000, () => {
                    this.action = false;
                }, [], this);
            }
        }
    }

    /**
     * Función callback que contiene la logica detrás dela interaccion entre la herramienta del jugador y el gato
     * dependiendo de su estado
     */
    toolAndCat() {
        var stateChanged = false;
        var player = this.scene.player;
        switch (this.state) {
            case 'SICK':
                if (player.tool.selectedTool == 'MED') {
                    this.state = 'NORMAL';
                    player.dropTool();
                    stateChanged = true;
                }
                break;
            case 'BORED':
                if (player.tool.selectedTool == 'FUN') {
                    this.state = 'NORMAL';
                    player.dropTool();
                    stateChanged = true;
                }
                break;
        }
        if (stateChanged) {
            if (this.type == 'GREEN') this.scene.judge.addPoints(10);
            if (this.type == 'YELLOW') this.scene.judge.addPoints(15);
            if (this.type == 'RED') this.scene.judge.addPoints(30);
            if (!this.mindlessCat) {
                this.stateTimer.paused = true;
                this.scene.time.delayedCall(1000, () => {
                    this.stateTimer.paused = false;
                }, [], this);
            }
        }

    }

    /**
     * Función que dado un par coordenado regresa el objeto Plate en dicha posición
     * @param {integer[]} coord 
     * @returns {Plate}
     */
    plateByCoord(coord) {
        var a = null;
        this.scene.plates.forEach(plate => {
            if (plate.plate.x == coord) {
                a = plate;
            }
        });
        return a;
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Cat.html">Cat</a></li><li><a href="Ground.html">Ground</a></li><li><a href="Judge.html">Judge</a></li><li><a href="Main.html">Main</a></li><li><a href="MPtest.html">MPtest</a></li><li><a href="OtherP.html">OtherP</a></li><li><a href="PauseMenu.html">PauseMenu</a></li><li><a href="Plate.html">Plate</a></li><li><a href="Player.html">Player</a></li><li><a href="PlayersInfo.html">PlayersInfo</a></li><li><a href="ScenaP.html">ScenaP</a></li><li><a href="ServerCreator.html">ServerCreator</a></li><li><a href="Shelter.html">Shelter</a></li><li><a href="Tool.html">Tool</a></li><li><a href="Winner.html">Winner</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.6</a> on Fri Nov 27 2020 06:16:26 GMT-0500 (GMT-05:00)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
